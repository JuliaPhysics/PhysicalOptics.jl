var documenterSearchIndex = {"docs":
[{"location":"#PhysicalOptics.jl","page":"PhysicalOptics.jl","title":"PhysicalOptics.jl","text":"A package for simulation of physical optics. Physical optics is more general than ray optics but not as general as full electrodynamics.\n\nCheckout GitHub for news and source code.","category":"section"},{"location":"#PhysicalOptics.apply_rot_symmetry-NTuple{4, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.apply_rot_symmetry","text":"apply_rot_symmetry(arr, xs, xs_out, ys_out)\n\nTakes a 1D array arr with rotational symmetry about the center point. arr should have values evaluates at the positions xs.\n\nxs_out and ys_out are the positions for the output array. We interpolate arr and evaluate it at distances sqrt(xs_out[j]^2+ys_out[i]^2).\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.calc_NA","page":"PhysicalOptics.jl","title":"PhysicalOptics.calc_NA","text":"calc_NA(focal_length, diameter[, n])\n\nCalculate the numerical aperture of a system with focal_length  and diameter of the lens. Per default n=1 is the refractive index.\n\nExamples\n\njulia> calc_NA(100e-3, 200e-3)\n1.0\n\njulia> calc_NA(100e-3, 200e-3, 1.33)\n1.33\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.calc_k","page":"PhysicalOptics.jl","title":"PhysicalOptics.calc_k","text":"calc_k(λ, n=1)\n\nCalculate the value of the (angular) wave number with vacuum wavelength λ in medium with refractive index n. It holds: $ k = \\kappa \\cdot 2 \\pi $\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.calc_κ","page":"PhysicalOptics.jl","title":"PhysicalOptics.calc_κ","text":"calc_κ(λ, n=1)\n\nCalculate the value of the (non angular) wave number with vacuum wavelength λ in medium with refractive index n. It holds: $ \\kappa = \\frac{k}{2 \\pi} $\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.calc_λ","page":"PhysicalOptics.jl","title":"PhysicalOptics.calc_λ","text":"calc_λ(k, n=1)\n\nCalculate the vacuum wavelength λ from the angular wave number k in  medium with refractive index n. It holds: $ \\lambda = \\frac{n \\cdot 2 \\pi}{k} $\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.center_extract-Tuple{AbstractArray, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.center_extract","text":"center_extract(arr, new_size_array)\n\nExtracts a center of an array.  new_size_array must be list of sizes indicating the output size of each dimension. Centered means that a center frequency stays at the center position. Works for even and uneven. If length(new_size_array) < length(ndims(arr)) the remaining dimensions are untouched and copied.\n\nExamples\n\njulia> center_extract([1 2; 3 4], [1]) \n1×2 Array{Int64,2}:\n 3  4\njulia> center_extract([1 2; 3 4], [1, 1])\n1×1 Array{Int64,2}:\n 4\njulia> center_extract([1 2 3; 3 4 5; 6 7 8], [2 2])\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.center_pos-Tuple{Integer}","page":"PhysicalOptics.jl","title":"PhysicalOptics.center_pos","text":"center_pos(x)\n\nCalculate the position of the center frequency. Size of the array is x\n\nExamples\n\njulia> center_pos(3)\n2\njulia> center_pos(4)\n3\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.center_set!-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.center_set!","text":"center_set!(arr_large, arr_small)\n\nPuts the arr_small central into arr_large. The convention, where the center is, is the same as the definition as for FFT based centered. Function works both for even and uneven arrays.\n\nExamples\n\njulia> center_set!([1, 1, 1, 1, 1, 1], [5, 5, 5])\n6-element Array{Int64,1}:\n 1\n 1\n 5\n 5\n 5\n 1\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.circ-Tuple{AbstractArray, Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.circ","text":"circ(arr, L, radius_aperture)\n\nApply circular aperture of radius radius_aperture to an array which has field width of L. circ! is also available.\n\njulia> circ(ones((5, 5)), 5, 2.5)\n5×5 Array{Float64,2}:\n 0.0  0.0  1.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0\n 1.0  1.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0  0.0\n 0.0  0.0  1.0  0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.circ-Tuple{Any, Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.circ","text":"circ(radius_aperture, x, y)\n\nRespresenting an aperture. Being 0 if x^2 + y^2 > radius_aperture^2 and otherwise 1.\n\nExamples\n\njulia> circ(1, 0, 1)\n1\n\njulia> circ(1, 0.5, 0.5)\n1\n\njulia> circ(1, 1, 1)\n0\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.circ-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.circ","text":"circ(radius_aperture, r)\n\nRespresenting an aperture. Being 0 if r^2 > radius_aperture^2 and otherwise 1.\n\nExamples\n\njulia> circ(1, 0)\n1\n\njulia> circ(1, 1)\n1\n\njulia> circ(1, 1.01)\n0\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.conv","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv","text":"conv(u, v[, dims]; shift=false, real_res=false)\n\nConvolve u with v over dims dimensions.\n\nArguments\n\nu is an array in real space.\nv is the array to be convolved.\nPer default dims=1:ndims(v) means that we perform the convolution    over all dimensions of v.    If dims is an array with integers, we perform convolution    only over these dimensions. Eg. dims=[1,3] would perform the convolution   over the first and third dimension. Second dimension is not convolved.\nPer default shift=false therefore we assume that the center point of v   is alreay ifftshifted to the first entry of the array.\nPer default real_res=false means that the output will be real. Otherwise we cut   off the imaginary part.\n\nExamples\n\n1D with FFT over all dimensions. We choose v to be a delta peak. Therefore convolution should act as identity.\n\njulia> u = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> v = [0 0 1 0 0]\n1×5 Array{Int64,2}:\n 0  0  1  0  0\n\njulia> conv(u, v)\n1×5 Array{Complex{Float64},2}:\n 4.0+0.0im  5.0+0.0im  1.0+0.0im  2.0+0.0im  3.0+0.0im\n\njulia> conv(u, v, real_res=true) # since v is not ifftshifted with peak at the first entry, we see a wrong result.\n1×5 Array{Float64,2}:\n 4.0  5.0  1.0  2.0  3.0\n\njulia> conv(u, v, shift=true, real_res=true)\n1×5 Array{Float64,2}:\n 1.0  2.0  3.0  4.0  5.0\n\njulia> conv(u, ifftshift(v), real_res=true)\n1×5 Array{Float64,2}:\n 1.0  2.0  3.0  4.0  5.0\n\n2D with FFT with different dims arguments.\n\njulia> u = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> v = [1 0 0; 1 0 0]\n2×3 Array{Int64,2}:\n 1  0  0\n 1  0  0\n\njulia> conv(u, v, [2])\n2×3 Array{Complex{Float64},2}:\n 1.0+0.0im  2.0+0.0im  3.0+0.0im\n 4.0+0.0im  5.0+0.0im  6.0+0.0im\n\njulia> conv(u, v, [2], real_res=true)\n2×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n\njulia> conv(u, v, [1, 2], real_res=true) # now we do a 2D convolution which is not identity anymore\n2×3 Array{Float64,2}:\n 5.0  7.0  9.0\n 5.0  7.0  9.0\n\njulia> conv(u, v, real_res=true) # same statement as above\n2×3 Array{Float64,2}:\n 5.0  7.0  9.0\n 5.0  7.0  9.0\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.conv_otf","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv_otf","text":"conv_otf(obj, otf [ , dims])\n\nPerforms a FFT-based convolution of an obj with otf. Wrapper for conv_v_ft(obj, otf, dims, real_res=true). Check the help of conv_v_ft for more details and examples.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.conv_otf_r","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv_otf_r","text":"conv_otf_r(obj, otf [, dims])\n\nPerforms a FFT-based convolution of an obj with an otf. Same arguments as conv_otf but with obj being real and otf=rfft(psf). All FFTs are computed with rfft and irfft.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.conv_psf","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv_psf","text":"conv_psf(obj, psf [, dims]; shift=false)\n\nConvolve obj with psf over dims dimensions. Based on FFT convolution.  This function calls conv, check the help of this method. Wrapper for conv(obj, psf, dims, shift=shift, real_res=true)\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.conv_sum_2D-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv_sum_2D","text":"This convolution is based on the real space sliding scheme. The kernel is expected to have the center point in the way like FFT defines it\n\narr is the arr and kernel is the small kernel.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.conv_v_ft","page":"PhysicalOptics.jl","title":"PhysicalOptics.conv_v_ft","text":"conv_v_ft(u, v_ft[, dims]; real_res=false)\n\nConvolve u with v_ft over dims dimensions. Based on FFT convolution.\n\nArguments\n\nu is an array in real space.\nv_ft is the array to be convolved with in Fourier space.    Therefore you have to check yourself that v was shifted correctly   in real space.\nPer default dims=1:ndims(v_ft) means that we perform the convolution    over all dimensions of v_ft.    If dims is an array with integers, we perform convolution    only over these dimensions. Eg. dims=[1,3] would perform the convolution   over the first and third dimension. Second dimension is not convolved.\nPer default real_res=false means that the output will be real. Otherwise we cut   off the imaginary part.\n\nExamples\n\nConvolution with delta peak is an identity operation\n\njulia> u = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> v = [1 0 0 0 0]\n1×5 Array{Int64,2}:\n 1  0  0  0  0\n\njulia> v_ft = fft(v)\n1×5 Array{Complex{Float64},2}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im  1.0+0.0im  1.0+0.0im\n\njulia> conv_v_ft(u, v_ft)\n1×5 Array{Complex{Float64},2}:\n 1.0+0.0im  2.0+0.0im  3.0+0.0im  4.0+0.0im  5.0+0.0im\n\njulia> conv_v_ft(u, v_ft, real_res=true)\n1×5 Array{Float64,2}:\n 1.0  2.0  3.0  4.0  5.0\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.debye_focus-NTuple{4, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.debye_focus","text":"debye_focus(L, N, NA, z; λ=550e-9, n=1)\n\nEvaluates the Debye integral to get the electrical field at position z with  respect to the focus of the lens.  z>0 means farther away from the lens than the focus and vice versa. Lens has a numerical aperture NA.  λ is the wavelength and n the refractive index.\n\nReturns a quadratic array with size (N, N). The side length is L, specifically fftpos(L, N) are the coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.fft_view_tuple","page":"PhysicalOptics.jl","title":"PhysicalOptics.fft_view_tuple","text":"fft_view_tuple(x[, shift, dims])\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.fftpos-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.fftpos","text":"fftpos(L, N)\n\nConstruct a range from -L/2 to L/2. However, we ensure that everything is centered around the center in a way that a FFT interpretes it correctly. For odd sequences it is indeed in the real center. For even sequences the center is at N/2 + 1.\n\nExamples\n\njulia> collect(fftpos(1, 4))\n4-element Array{Float64,1}:\n -0.5\n -0.25\n  0.0\n  0.25\n\njulia> collect(fftpos(1, 5))\n5-element Array{Float64,1}:\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.four_f_propagate-NTuple{5, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.four_f_propagate","text":"four_f_propagate(arr, L, f1, f2, NA; fft_plan=fft_plan, d=nothing)\n\nPropagate the electrical field arr (field size L) from front focal plane to the back focal plane of a 4f system. The focal length of the first lens is f1 and the second lens f. Magnification of the system is then f2/f1. d is the distance from lens to the point of the arr in front of the lens. If d == nothing then we propagate from object plane to image plane.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.fresnel_kernel","page":"PhysicalOptics.jl","title":"PhysicalOptics.fresnel_kernel","text":"fresnel_kernel(fx, fy, z, λ, n=1.0)\n\nCalculates the Fresnel propagation kernel in Fourier space. fx, f_y are the spatial frequency. z is the propagation distance. λ is the wavelength and n the refractive index.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.fresnel_number","page":"PhysicalOptics.jl","title":"PhysicalOptics.fresnel_number","text":"fresnel_number(a, L, λ=λ0)\n\nCalculate the Fresnel number where a is the characteristic size, L the distance from screen to aperture and λ the wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.get_index_for_pos-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.get_index_for_pos","text":"get_index_for_pos(pos_arr, pos)\n\nFor a arr containing range like data, return the index which is closest to the pos value\n\nExample\n\njulia> pos = collect(fftpos(1, 5))\n5-element Vector{Float64}:\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n\njulia> get_index_for_pos(pos, 0.124)\n3\n\njulia> get_index_for_pos(pos, 0.1251)\n4\n\njulia> pos = collect(fftpos(1, 6))\n6-element Vector{Float64}:\n -0.5\n -0.3333333333333333\n -0.16666666666666666\n  2.2204460492503052e-17\n  0.16666666666666669\n  0.33333333333333337\n\njulia> get_index_for_pos(pos, 0)\n4\n\njulia> get_index_for_pos(pos, 0.1)\n5\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.get_indices_around_center-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.get_indices_around_center","text":"get_indices_around_center(i_in, i_out)\n\nA function which provides two output indices i1 and i2 where i2 - i1 = i_out The indices are chosen in a way that the set i1:i2 cuts the interval 1:i_in in a way that the center frequency stays at the center position. Works for both odd and even indices\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.jinc-Tuple{T} where T","page":"PhysicalOptics.jl","title":"PhysicalOptics.jinc","text":"jinc(x)\n\nComputes the jinc function which is textjinc = fracJ_1(x)x where J_1 being the first Bessel function.\n\nIn future, probably switch to: https://github.com/JuliaMath/SpecialFunctions.jl/issues/264\n\nExamples\n\njulia> jinc(0.0)\n0.5\n\njulia> jinc(0.0im)\n0.5 + 0.0im\n\njulia> jinc(0.0001im)\n0.5000000006250005 - 3.0616170016954073e-17im\n\njulia> jinc(1.0f0)\n0.44005057f0\n\njulia> jinc.([0.0 0.5 1.0])\n1×3 Array{Float64,2}:\n 0.5  0.484537  0.440051\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.jinc_psf","page":"PhysicalOptics.jl","title":"PhysicalOptics.jinc_psf","text":"jinc_psf(psf_size, L, radius[, f]; λ=550e-9, shift=false)\n\nGenerate the normalized, incoherent 2D jinc PSF of a circular aperture. psf_size is output array shape. L is the width of the array expressed in meter. radius is the aperture radius in meter. Keyword arguments λ and f=100e-3 represent wavelength and focal length of the lens respectively.\n\nReference: Mertz, J. (2019). Introduction to Optical Microscopy (2nd ed.).\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.lens","page":"PhysicalOptics.jl","title":"PhysicalOptics.lens","text":"lens(f, L, size=(512, 512); λ=550e-9, n=1)\n\nReturn complex lens transmission value for a field of size  and a length of L The lens has a focal length f and the surrounding medium has  refractive index n. Wavelength is λ.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.lens-Tuple{Number, Number, Number}","page":"PhysicalOptics.jl","title":"PhysicalOptics.lens","text":"lens(f, x, y; λ=550e-9, n=1)\n\nReturn complex transmission value at position x and y  for a lens. The lens has a focal length f and the surrounding medium has  refractive index n. Wavelength is λ.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.lens_propagate-Tuple{Any, Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.lens_propagate","text":"lens_propagate(arr, L, f; λ=550e-9, n=1, d=nothing)\n\nPropagate an electrical field of width L at a distance d in front of a lens with focal length f in medium with refractive index n to the back focal plane of the lens. Per default d=nothing meaning that we set d=f. Assume same sampling and size in both dimensions. As return parameter we get the resulting field and the new field size. Essentially the lens (assuminig infinite large of that lens) performs a scaled Fourier transform. Therefore we get a new field size.\n\nReference\n\nBased on:\n\n\"Computational Fourier Optics. A MATLAB Tutorial\", D. Voelz, (2011).\nGoodman, Joseph W. Introduction to Fourier optics\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.micro_lens_array","page":"PhysicalOptics.jl","title":"PhysicalOptics.micro_lens_array","text":"micro_lens_array(f, L, pitch, size=(512, 512); centered=true, λ=550e-9, n=1, aperture=true,\n                 dtype=ComplexF32)\n\nReturn a micro lens array (MLA) with pitch size pitch in the field size of L. All lenslets have the same focal length f. As default centered=true means that the there is a micro lens centered around the center of the array. aperture=true indicates that there is a circular aperture cutting the field. Otherwise the aperture are square shaped of the same size as the pitch.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.mla_propagate-NTuple{6, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.mla_propagate","text":"mla_propagate(E, L, fmla, p_mla, z1, z2)\n\nPropagate an electrical field E placed a distance z1 in front of a microlns array, to a distance z2 behind the microlens array. L is the size of the field and fmla is the focal length of the lenslets. p_mla is microlenses pitch.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.normabs2-Tuple{Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.normabs2","text":"normabs2(arr)\n\nTakes abs2 and normalizes maximum to 1\n\nExamples\n\njulia> normabs2([10.0, 12.1])\n2-element Array{Float64,1}:\n 0.6830134553650707\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.plan_conv_r","page":"PhysicalOptics.jl","title":"PhysicalOptics.plan_conv_r","text":"plan_conv_r(psf [, dims])\n\nPre-plan an optimized convolution for array shaped like psf (based on pre-plan FFT) along the given dimenions dims. dims = 1:ndims(psf) per default. The 0 frequency of psf must be located at the first entry. We return first the otf (obtained by rfft(psf)). The second return is the convolution function pconv. pconv itself has two arguments. pconv(obj, otf) where obj is the object and otf the otf. This function achieves faster convolution than conv_psf(obj, psf).\n\nExamples\n\njulia> u = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> v = [1 0 0 0 0]\n1×5 Array{Int64,2}:\n 1  0  0  0  0\n\njulia> otf, pconv = plan_conv_r(v)\n(Complex{Float64}[1.0 + 0.0im 1.0 + 0.0im … 1.0 + 0.0im 1.0 + 0.0im], PhysicalOptics.var\"#conv#49\"{FFTW.rFFTWPlan{Float64,-1,false,2,UnitRange{Int64}},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.rFFTWPlan{Complex{Float64},1,false,2,UnitRange{Int64}},Float64}}(FFTW real-to-complex plan for 1×5 array of Float64\n(rdft2-rank>=2/1\n  (rdft2-r2hc-rank0-x5)\n  (dft-direct-5 \"n1fv_5_avx2_128\")), 0.2 * FFTW complex-to-real plan for 1×5 array of Complex{Float64}\n(rdft2-rank>=2/1\n  (rdft2-hc2r-rank0\n    (rdft-rank0-iter-ci/1-x5))\n  (dft-direct-5 \"n1bv_5_avx2_128\"))))\n\njulia> pconv(u, otf)\n1×5 Array{Float64,2}:\n 1.0  2.0  3.0  4.0  5.0\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.point_source_propagate-Tuple{Any, Any, Point}","page":"PhysicalOptics.jl","title":"PhysicalOptics.point_source_propagate","text":"point_source_propagate(L, size, point; λ=550e-9, n=1, dtype=ComplexF64)\n\nPropagate a point source in a field of width L with array size size  over a distance z in a medium with refractive index n. Point source is located at position point(x, y, z) and then propagated to  a location z=0. z<0 in point means forward propagation.\n\nThis is based on the analytical solution in real space and not on Fourier space propagation. The latter one suffers from artifacts while microscopic large L. This function should be always preferred for point sources.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.propagate!-Tuple{Any, Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.propagate!","text":"propagate!(arr, L, z; kernel=rs_kernel, λ=550e-9, n=1)\n\nPropagate an electric field arr with a array size (in physical dimensions like meter etc) of L over the distance z. Per default kernel=rs_kernel (Rayleigh-Sommerfeld) is the propagation kernel.  λ is the wavelength and n the refractive index.\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.quadratic","page":"PhysicalOptics.jl","title":"PhysicalOptics.quadratic","text":"quadratic(arr, L, diameter, [, diameter=(0,0)])\n\nApply a quadratic aperture of diameter to an  array which has a field width of L. The aperture is shifted by Δx, Δy with respect to the center\n\nThere is also an in-place version quadratic!\n\njulia> quadratic(ones((4, 4)), 10, 5)\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0\n\njulia> quadratic(ones((5, 5)), 10, 5)\n5×5 Array{Float64,2}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  1.0  1.0  0.0\n 0.0  1.0  1.0  1.0  0.0\n 0.0  1.0  1.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n\njulia> quadratic(ones((5, 5)), 5, 2.5, (0.0, 1.25)) \n5×5 Array{Float64,2}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0  1.0\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.rayleigh_criterion-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.rayleigh_criterion","text":"rayleigh_criterion(focal_length, diameter; λ=500e-9)\n\nCalculates the resolution of a microscope according to Rayleigh. focal_length is the focal length of the lens. λ is the wavelength and diameter is the diameter of the aperture of the lens. See Wikipedia.\n\nExamples\n\njulia> rayleigh_criterion(100, 200)\n3.05e-7\n\njulia> rayleigh_criterion(100, 200, λ=100e-9)\n6.099999999999999e-8\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.rayleigh_criterion-Tuple{Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.rayleigh_criterion","text":"rayleigh_criterion(NA; λ=500e-9)\n\nCalculates the resolution of a microscope according to Rayleigh. λ is the wavelength and NA the numerical aperture of the system. See Wikipedia.\n\nExamples\n\njulia> rayleigh_criterion(1.0)\n3.05e-7\n\njulia> rayleigh_criterion(1.0, λ=100e-9)\n6.099999999999999e-8\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.rr_old-Tuple{Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.rr_old","text":"rr(s; L=nothing)\n\nGenerate a array with values being the distance to the center pixel. s specifies the output size of the 2D array. L specifies the length. Can be a single number indicating the same length for both dimensions or a tuple specifying a length for each  dimension separately.\n\nExamples\n\njulia> PhysicalOptics.rr((4,4))\n4×4 Matrix{Float64}:\n 2.82843  2.23607  2.0  2.23607\n 2.23607  1.41421  1.0  1.41421\n 2.0      1.0      0.0  1.0\n 2.23607  1.41421  1.0  1.41421\n\njulia> PhysicalOptics.rr((4,4), L=1)\n4×4 Matrix{Float64}:\n 0.707107  0.559017  0.5   0.559017\n 0.559017  0.353553  0.25  0.353553\n 0.5       0.25      0.0   0.25\n 0.559017  0.353553  0.25  0.353553\n\njulia> PhysicalOptics.rr((4,4), L=(5, 1))\n4×4 Matrix{Float64}:\n 2.54951  1.34629  0.5   1.34629\n 2.51247  1.27475  0.25  1.27475\n 2.5      1.25     0.0   1.25\n 2.51247  1.27475  0.25  1.27475\n\njulia> PhysicalOptics.rr((5,5), L=(1, 1))\n5×5 Matrix{Float64}:\n 0.707107  0.559017  0.5   0.559017  0.707107\n 0.559017  0.353553  0.25  0.353553  0.559017\n 0.5       0.25      0.0   0.25      0.5\n 0.559017  0.353553  0.25  0.353553  0.559017\n 0.707107  0.559017  0.5   0.559017  0.707107\n\n\n\n\n\n","category":"method"},{"location":"#PhysicalOptics.rs_kernel","page":"PhysicalOptics.jl","title":"PhysicalOptics.rs_kernel","text":"rs_kernel(fx, fy, z, λ, n=1.0)\n\nCalculates the Rayleigh-Sommerfeld propagation kernel in Fourier space. fx, f_y are the spatial frequencies. z is the propagation distance. λ is the wavelength and n the refractive index.\n\n\n\n\n\n","category":"function"},{"location":"#PhysicalOptics.simple_psf-Tuple{Any, Any}","page":"PhysicalOptics.jl","title":"PhysicalOptics.simple_psf","text":"simple_psf(psf_size, radius; shift=false)\n\nGeneration of an approximate 2D PSF. psf_size is the output size of the PSF. The PSF will be centered around the point [1, 1], radius indicates the pupil diameter in pixel from which the PSF is generated.\n\nExamples\n\njulia> simple_psf([5, 5], 2)\n5×5 Array{Float64,2}:\n 0.36       0.104721    0.0152786    0.0152786    0.104721\n 0.104721   0.0304627   0.00444444   0.00444444   0.0304627\n 0.0152786  0.00444444  0.000648436  0.000648436  0.00444444\n 0.0152786  0.00444444  0.000648436  0.000648436  0.00444444\n 0.104721   0.0304627   0.00444444   0.00444444   0.0304627\n\n\n\n\n\n","category":"method"}]
}
