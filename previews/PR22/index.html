<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PhysicalOptics.jl · PhysicalOptics.jl</title><meta name="title" content="PhysicalOptics.jl · PhysicalOptics.jl"/><meta property="og:title" content="PhysicalOptics.jl · PhysicalOptics.jl"/><meta property="twitter:title" content="PhysicalOptics.jl · PhysicalOptics.jl"/><meta name="description" content="Documentation for PhysicalOptics.jl."/><meta property="og:description" content="Documentation for PhysicalOptics.jl."/><meta property="twitter:description" content="Documentation for PhysicalOptics.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PhysicalOptics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>PhysicalOptics.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>PhysicalOptics.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PhysicalOptics.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/PhysicalOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PhysicalOptics.jl"><a class="docs-heading-anchor" href="#PhysicalOptics.jl">PhysicalOptics.jl</a><a id="PhysicalOptics.jl-1"></a><a class="docs-heading-anchor-permalink" href="#PhysicalOptics.jl" title="Permalink"></a></h1><p>A package for simulation of physical optics. Physical optics is more general than ray optics but not as general as full electrodynamics.</p><p>Checkout <a href="https://github.com/JuliaPhysics/PhysicalOptics.jl">GitHub</a> for news and source code.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.apply_rot_symmetry-NTuple{4, Any}" href="#PhysicalOptics.apply_rot_symmetry-NTuple{4, Any}"><code>PhysicalOptics.apply_rot_symmetry</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_rot_symmetry(arr, xs, xs_out, ys_out)</code></pre><p>Takes a 1D array <code>arr</code> with rotational symmetry about the center point. <code>arr</code> should have values evaluates at the positions <code>xs</code>.</p><p><code>xs_out</code> and <code>ys_out</code> are the positions for the output array. We interpolate <code>arr</code> and evaluate it at distances <code>sqrt(xs_out[j]^2+ys_out[i]^2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L381-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.calc_NA" href="#PhysicalOptics.calc_NA"><code>PhysicalOptics.calc_NA</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_NA(focal_length, diameter[, n])</code></pre><p>Calculate the numerical aperture of a system with <code>focal_length</code>  and <code>diameter</code> of the lens. Per default <code>n=1</code> is the refractive index.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; calc_NA(100e-3, 200e-3)
1.0

julia&gt; calc_NA(100e-3, 200e-3, 1.33)
1.33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/physical_conversions.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.calc_k" href="#PhysicalOptics.calc_k"><code>PhysicalOptics.calc_k</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_k(λ, n=1)</code></pre><p>Calculate the value of the (angular) wave number with vacuum wavelength <code>λ</code> in medium with refractive index <code>n</code>. It holds: $ k = \kappa \cdot 2 \pi $</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/physical_conversions.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.calc_κ" href="#PhysicalOptics.calc_κ"><code>PhysicalOptics.calc_κ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_κ(λ, n=1)</code></pre><p>Calculate the value of the (non angular) wave number with vacuum wavelength <code>λ</code> in medium with refractive index <code>n</code>. It holds: $ \kappa = \frac{k}{2 \pi} $</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/physical_conversions.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.calc_λ" href="#PhysicalOptics.calc_λ"><code>PhysicalOptics.calc_λ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_λ(k, n=1)</code></pre><p>Calculate the vacuum wavelength <code>λ</code> from the angular wave number <code>k</code> in  medium with refractive index <code>n</code>. It holds: $ \lambda = \frac{n \cdot 2 \pi}{k} $</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/physical_conversions.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.center_extract-Tuple{AbstractArray, Any}" href="#PhysicalOptics.center_extract-Tuple{AbstractArray, Any}"><code>PhysicalOptics.center_extract</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center_extract(arr, new_size_array)</code></pre><p>Extracts a center of an array.  <code>new_size_array</code> must be list of sizes indicating the output size of each dimension. Centered means that a center frequency stays at the center position. Works for even and uneven. If <code>length(new_size_array) &lt; length(ndims(arr))</code> the remaining dimensions are untouched and copied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; center_extract([1 2; 3 4], [1]) 
1×2 Array{Int64,2}:
 3  4
julia&gt; center_extract([1 2; 3 4], [1, 1])
1×1 Array{Int64,2}:
 4
julia&gt; center_extract([1 2 3; 3 4 5; 6 7 8], [2 2])
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L153-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.center_pos-Tuple{Integer}" href="#PhysicalOptics.center_pos-Tuple{Integer}"><code>PhysicalOptics.center_pos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center_pos(x)</code></pre><p>Calculate the position of the center frequency. Size of the array is <code>x</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; center_pos(3)
2
julia&gt; center_pos(4)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.center_set!-Tuple{Any, Any}" href="#PhysicalOptics.center_set!-Tuple{Any, Any}"><code>PhysicalOptics.center_set!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center_set!(arr_large, arr_small)</code></pre><p>Puts the <code>arr_small</code> central into <code>arr_large</code>. The convention, where the center is, is the same as the definition as for FFT based centered. Function works both for even and uneven arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; center_set!([1, 1, 1, 1, 1, 1], [5, 5, 5])
6-element Array{Int64,1}:
 1
 1
 5
 5
 5
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L192-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.circ-Tuple{AbstractArray, Any, Any}" href="#PhysicalOptics.circ-Tuple{AbstractArray, Any, Any}"><code>PhysicalOptics.circ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circ(arr, L, radius_aperture)</code></pre><p>Apply circular aperture of radius <code>radius_aperture</code> to an array which has field width of <code>L</code>. <code>circ!</code> is also available.</p><pre><code class="language-julia-repl hljs">julia&gt; circ(ones((5, 5)), 5, 2.5)
5×5 Array{Float64,2}:
 0.0  0.0  1.0  0.0  0.0
 0.0  1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0  0.0
 0.0  0.0  1.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/apertures.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.circ-Tuple{Any, Any, Any}" href="#PhysicalOptics.circ-Tuple{Any, Any, Any}"><code>PhysicalOptics.circ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circ(radius_aperture, x, y)</code></pre><p>Respresenting an aperture. Being 0 if <code>x^2 + y^2 &gt; radius_aperture^2</code> and otherwise 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circ(1, 0, 1)
1

julia&gt; circ(1, 0.5, 0.5)
1

julia&gt; circ(1, 1, 1)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/apertures.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.circ-Tuple{Any, Any}" href="#PhysicalOptics.circ-Tuple{Any, Any}"><code>PhysicalOptics.circ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circ(radius_aperture, r)</code></pre><p>Respresenting an aperture. Being 0 if <code>r^2 &gt; radius_aperture^2</code> and otherwise 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circ(1, 0)
1

julia&gt; circ(1, 1)
1

julia&gt; circ(1, 1.01)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/apertures.jl#L32-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv" href="#PhysicalOptics.conv"><code>PhysicalOptics.conv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conv(u, v[, dims]; shift=false, real_res=false)</code></pre><p>Convolve <code>u</code> with <code>v</code> over <code>dims</code> dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>u</code> is an array in real space.</li><li><code>v</code> is the array to be convolved.</li><li>Per default <code>dims=1:ndims(v)</code> means that we perform the convolution    over all dimensions of <code>v</code>.    If <code>dims</code> is an array with integers, we perform convolution    only over these dimensions. Eg. <code>dims=[1,3]</code> would perform the convolution   over the first and third dimension. Second dimension is not convolved.</li><li>Per default <code>shift=false</code> therefore we assume that the center point of <code>v</code>   is alreay ifftshifted to the first entry of the array.</li><li>Per default <code>real_res=false</code> means that the output will be real. Otherwise we cut   off the imaginary part.</li></ul><p><strong>Examples</strong></p><p>1D with FFT over all dimensions. We choose <code>v</code> to be a delta peak. Therefore convolution should act as identity.</p><pre><code class="language-julia-repl hljs">julia&gt; u = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; v = [0 0 1 0 0]
1×5 Array{Int64,2}:
 0  0  1  0  0

julia&gt; conv(u, v)
1×5 Array{Complex{Float64},2}:
 4.0+0.0im  5.0+0.0im  1.0+0.0im  2.0+0.0im  3.0+0.0im

julia&gt; conv(u, v, real_res=true) # since v is not ifftshifted with peak at the first entry, we see a wrong result.
1×5 Array{Float64,2}:
 4.0  5.0  1.0  2.0  3.0

julia&gt; conv(u, v, shift=true, real_res=true)
1×5 Array{Float64,2}:
 1.0  2.0  3.0  4.0  5.0

julia&gt; conv(u, ifftshift(v), real_res=true)
1×5 Array{Float64,2}:
 1.0  2.0  3.0  4.0  5.0</code></pre><p>2D with FFT with different <code>dims</code> arguments.</p><pre><code class="language-julia-repl hljs">julia&gt; u = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; v = [1 0 0; 1 0 0]
2×3 Array{Int64,2}:
 1  0  0
 1  0  0

julia&gt; conv(u, v, [2])
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  2.0+0.0im  3.0+0.0im
 4.0+0.0im  5.0+0.0im  6.0+0.0im

julia&gt; conv(u, v, [2], real_res=true)
2×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0

julia&gt; conv(u, v, [1, 2], real_res=true) # now we do a 2D convolution which is not identity anymore
2×3 Array{Float64,2}:
 5.0  7.0  9.0
 5.0  7.0  9.0

julia&gt; conv(u, v, real_res=true) # same statement as above
2×3 Array{Float64,2}:
 5.0  7.0  9.0
 5.0  7.0  9.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L73-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv_otf" href="#PhysicalOptics.conv_otf"><code>PhysicalOptics.conv_otf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conv_otf(obj, otf [ , dims])</code></pre><p>Performs a FFT-based convolution of an <code>obj</code> with <code>otf</code>. Wrapper for <code>conv_v_ft(obj, otf, dims, real_res=true)</code>. Check the help of <code>conv_v_ft</code> for more details and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv_otf_r" href="#PhysicalOptics.conv_otf_r"><code>PhysicalOptics.conv_otf_r</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conv_otf_r(obj, otf [, dims])</code></pre><p>Performs a FFT-based convolution of an <code>obj</code> with an <code>otf</code>. Same arguments as <code>conv_otf</code> but with <code>obj</code> being real and <code>otf=rfft(psf)</code>. All FFTs are computed with <code>rfft</code> and <code>irfft</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L193-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv_psf" href="#PhysicalOptics.conv_psf"><code>PhysicalOptics.conv_psf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conv_psf(obj, psf [, dims]; shift=false)</code></pre><p>Convolve <code>obj</code> with <code>psf</code> over <code>dims</code> dimensions. Based on FFT convolution.  This function calls <code>conv</code>, check the help of this method. Wrapper for <code>conv(obj, psf, dims, shift=shift, real_res=true)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv_sum_2D-Tuple{Any, Any}" href="#PhysicalOptics.conv_sum_2D-Tuple{Any, Any}"><code>PhysicalOptics.conv_sum_2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This convolution is based on the real space sliding scheme. The kernel is expected to have the center point in the way like FFT defines it</p><p><code>arr</code> is the arr and <code>kernel</code> is the small kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L264-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.conv_v_ft" href="#PhysicalOptics.conv_v_ft"><code>PhysicalOptics.conv_v_ft</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conv_v_ft(u, v_ft[, dims]; real_res=false)</code></pre><p>Convolve <code>u</code> with <code>v_ft</code> over <code>dims</code> dimensions. Based on FFT convolution.</p><p><strong>Arguments</strong></p><ul><li><code>u</code> is an array in real space.</li><li><code>v_ft</code> is the array to be convolved with in Fourier space.    Therefore you have to check yourself that <code>v</code> was shifted correctly   in real space.</li><li>Per default <code>dims=1:ndims(v_ft)</code> means that we perform the convolution    over all dimensions of <code>v_ft</code>.    If <code>dims</code> is an array with integers, we perform convolution    only over these dimensions. Eg. <code>dims=[1,3]</code> would perform the convolution   over the first and third dimension. Second dimension is not convolved.</li><li>Per default <code>real_res=false</code> means that the output will be real. Otherwise we cut   off the imaginary part.</li></ul><p><strong>Examples</strong></p><p>Convolution with delta peak is an identity operation</p><pre><code class="language-julia-repl hljs">julia&gt; u = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; v = [1 0 0 0 0]
1×5 Array{Int64,2}:
 1  0  0  0  0

julia&gt; v_ft = fft(v)
1×5 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im  1.0+0.0im  1.0+0.0im

julia&gt; conv_v_ft(u, v_ft)
1×5 Array{Complex{Float64},2}:
 1.0+0.0im  2.0+0.0im  3.0+0.0im  4.0+0.0im  5.0+0.0im

julia&gt; conv_v_ft(u, v_ft, real_res=true)
1×5 Array{Float64,2}:
 1.0  2.0  3.0  4.0  5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L9-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.debye_focus-NTuple{4, Any}" href="#PhysicalOptics.debye_focus-NTuple{4, Any}"><code>PhysicalOptics.debye_focus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">debye_focus(L, N, NA, z; λ=550e-9, n=1)</code></pre><p>Evaluates the Debye integral to get the electrical field at position <code>z</code> with  respect to the focus of the lens.  <code>z&gt;0</code> means farther away from the lens than the focus and vice versa. Lens has a numerical aperture <code>NA</code>.  <code>λ</code> is the wavelength and <code>n</code> the refractive index.</p><p>Returns a quadratic array with size <code>(N, N)</code>. The side length is <code>L</code>, specifically <code>fftpos(L, N)</code> are the coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagation_integrals.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.fft_view_tuple" href="#PhysicalOptics.fft_view_tuple"><code>PhysicalOptics.fft_view_tuple</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fft_view_tuple(x[, shift, dims])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils_view.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.fftpos-Tuple{Any, Any}" href="#PhysicalOptics.fftpos-Tuple{Any, Any}"><code>PhysicalOptics.fftpos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fftpos(L, N)</code></pre><p>Construct a range from -L/2 to L/2. However, we ensure that everything is centered around the center in a way that a FFT interpretes it correctly. For odd sequences it is indeed in the real center. For even sequences the center is at <code>N/2 + 1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(fftpos(1, 4))
4-element Array{Float64,1}:
 -0.5
 -0.25
  0.0
  0.25

julia&gt; collect(fftpos(1, 5))
5-element Array{Float64,1}:
 -0.5
 -0.25
  0.0
  0.25
  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.four_f_propagate-NTuple{5, Any}" href="#PhysicalOptics.four_f_propagate-NTuple{5, Any}"><code>PhysicalOptics.four_f_propagate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">four_f_propagate(arr, L, f1, f2, NA; fft_plan=fft_plan, d=nothing)</code></pre><p>Propagate the electrical field <code>arr</code> (field size <code>L</code>) from front focal plane to the back focal plane of a 4f system. The focal length of the first lens is <code>f1</code> and the second lens <code>f</code>. Magnification of the system is then <code>f2/f1</code>. <code>d</code> is the distance from lens to the point of the <code>arr</code> in front of the lens. If <code>d == nothing</code> then we propagate from object plane to image plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.fresnel_kernel" href="#PhysicalOptics.fresnel_kernel"><code>PhysicalOptics.fresnel_kernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fresnel_kernel(fx, fy, z, λ, n=1.0)</code></pre><p>Calculates the Fresnel propagation kernel in Fourier space. <code>fx</code>, <code>f_y</code> are the spatial frequency. <code>z</code> is the propagation distance. <code>λ</code> is the wavelength and <code>n</code> the refractive index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.fresnel_number" href="#PhysicalOptics.fresnel_number"><code>PhysicalOptics.fresnel_number</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fresnel_number(a, L, λ=λ0)</code></pre><p>Calculate the Fresnel number where <code>a</code> is the characteristic size, <code>L</code> the distance from screen to aperture and <code>λ</code> the wavelength.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/physical_conversions.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.get_index_for_pos-Tuple{Any, Any}" href="#PhysicalOptics.get_index_for_pos-Tuple{Any, Any}"><code>PhysicalOptics.get_index_for_pos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_index_for_pos(pos_arr, pos)</code></pre><p>For a arr containing <code>range</code> like data, return the <code>index</code> which is closest to the <code>pos</code> value</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pos = collect(fftpos(1, 5))
5-element Vector{Float64}:
 -0.5
 -0.25
  0.0
  0.25
  0.5

julia&gt; get_index_for_pos(pos, 0.124)
3

julia&gt; get_index_for_pos(pos, 0.1251)
4

julia&gt; pos = collect(fftpos(1, 6))
6-element Vector{Float64}:
 -0.5
 -0.3333333333333333
 -0.16666666666666666
  2.2204460492503052e-17
  0.16666666666666669
  0.33333333333333337

julia&gt; get_index_for_pos(pos, 0)
4

julia&gt; get_index_for_pos(pos, 0.1)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L7-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.get_indices_around_center-Tuple{Any, Any}" href="#PhysicalOptics.get_indices_around_center-Tuple{Any, Any}"><code>PhysicalOptics.get_indices_around_center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_indices_around_center(i_in, i_out)</code></pre><p>A function which provides two output indices <code>i1</code> and <code>i2</code> where <code>i2 - i1 = i_out</code> The indices are chosen in a way that the set <code>i1:i2</code> cuts the interval <code>1:i_in</code> in a way that the center frequency stays at the center position. Works for both odd and even indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.jinc-Tuple{T} where T" href="#PhysicalOptics.jinc-Tuple{T} where T"><code>PhysicalOptics.jinc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jinc(x)</code></pre><p>Computes the jinc function which is <span>$\text{jinc} = \frac{J_1(x)}{x}$</span> where <span>$J_1$</span> being the first Bessel function.</p><p>In future, probably switch to: https://github.com/JuliaMath/SpecialFunctions.jl/issues/264</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; jinc(0.0)
0.5

julia&gt; jinc(0.0im)
0.5 + 0.0im

julia&gt; jinc(0.0001im)
0.5000000006250005 - 3.0616170016954073e-17im

julia&gt; jinc(1.0f0)
0.44005057f0

julia&gt; jinc.([0.0 0.5 1.0])
1×3 Array{Float64,2}:
 0.5  0.484537  0.440051</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L344-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.jinc_psf" href="#PhysicalOptics.jinc_psf"><code>PhysicalOptics.jinc_psf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jinc_psf(psf_size, L, radius[, f]; λ=550e-9, shift=false)</code></pre><p>Generate the normalized, incoherent 2D jinc PSF of a circular aperture. <code>psf_size</code> is output array shape. <code>L</code> is the width of the array expressed in meter. <code>radius</code> is the aperture radius in meter. Keyword arguments <code>λ</code> and <code>f=100e-3</code> represent wavelength and focal length of the lens respectively.</p><p>Reference: Mertz, J. (2019). Introduction to Optical Microscopy (2nd ed.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/psf.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.lens" href="#PhysicalOptics.lens"><code>PhysicalOptics.lens</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lens(f, L, size=(512, 512); λ=550e-9, n=1)</code></pre><p>Return complex lens transmission value for a field of <code>size</code>  and a length of <code>L</code> The lens has a focal length <code>f</code> and the surrounding medium has  refractive index <code>n</code>. Wavelength is <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/lenses.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.lens-Tuple{Number, Number, Number}" href="#PhysicalOptics.lens-Tuple{Number, Number, Number}"><code>PhysicalOptics.lens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lens(f, x, y; λ=550e-9, n=1)</code></pre><p>Return complex transmission value at position <code>x</code> and <code>y</code>  for a lens. The lens has a focal length <code>f</code> and the surrounding medium has  refractive index <code>n</code>. Wavelength is <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/lenses.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.lens_propagate-Tuple{Any, Any, Any}" href="#PhysicalOptics.lens_propagate-Tuple{Any, Any, Any}"><code>PhysicalOptics.lens_propagate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lens_propagate(arr, L, f; λ=550e-9, n=1, d=nothing)</code></pre><p>Propagate an electrical field of width <code>L</code> at a distance <code>d</code> in front of a lens with focal length <code>f</code> in medium with refractive index <code>n</code> to the back focal plane of the lens. Per default <code>d=nothing</code> meaning that we set <code>d=f</code>. Assume same sampling and size in both dimensions. As return parameter we get the resulting field and the new field size. Essentially the lens (assuminig infinite large of that lens) performs a scaled Fourier transform. Therefore we get a new field size.</p><p><strong>Reference</strong></p><p>Based on:</p><ul><li>&quot;Computational Fourier Optics. A MATLAB Tutorial&quot;, D. Voelz, (2011).</li><li>Goodman, Joseph W. Introduction to Fourier optics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L133-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.micro_lens_array" href="#PhysicalOptics.micro_lens_array"><code>PhysicalOptics.micro_lens_array</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">micro_lens_array(f, L, pitch, size=(512, 512); centered=true, λ=550e-9, n=1, aperture=true,
                 dtype=ComplexF32)</code></pre><p>Return a micro lens array (MLA) with pitch size <code>pitch</code> in the field size of <code>L</code>. All lenslets have the same focal length <code>f</code>. As default <code>centered=true</code> means that the there is a micro lens centered around the center of the array. <code>aperture=true</code> indicates that there is a circular aperture cutting the field. Otherwise the aperture are square shaped of the same size as the <code>pitch</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/lenses.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.mla_propagate-NTuple{6, Any}" href="#PhysicalOptics.mla_propagate-NTuple{6, Any}"><code>PhysicalOptics.mla_propagate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mla_propagate(E, L, fmla, p_mla, z1, z2)</code></pre><p>Propagate an electrical field <code>E</code> placed a distance <code>z1</code> in front of a microlns array, to a distance <code>z2</code> behind the microlens array. <code>L</code> is the size of the field and <code>fmla</code> is the focal length of the lenslets. <code>p_mla</code> is microlenses pitch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.normabs2-Tuple{Any}" href="#PhysicalOptics.normabs2-Tuple{Any}"><code>PhysicalOptics.normabs2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normabs2(arr)</code></pre><p>Takes abs2 and normalizes maximum to 1</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; normabs2([10.0, 12.1])
2-element Array{Float64,1}:
 0.6830134553650707
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.plan_conv_r" href="#PhysicalOptics.plan_conv_r"><code>PhysicalOptics.plan_conv_r</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_conv_r(psf [, dims])</code></pre><p>Pre-plan an optimized convolution for array shaped like <code>psf</code> (based on pre-plan FFT) along the given dimenions <code>dims</code>. <code>dims = 1:ndims(psf)</code> per default. The 0 frequency of <code>psf</code> must be located at the first entry. We return first the <code>otf</code> (obtained by <code>rfft(psf))</code>. The second return is the convolution function <code>pconv</code>. <code>pconv</code> itself has two arguments. <code>pconv(obj, otf)</code> where <code>obj</code> is the object and <code>otf</code> the otf. This function achieves faster convolution than <code>conv_psf(obj, psf)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; v = [1 0 0 0 0]
1×5 Array{Int64,2}:
 1  0  0  0  0

julia&gt; otf, pconv = plan_conv_r(v)
(Complex{Float64}[1.0 + 0.0im 1.0 + 0.0im … 1.0 + 0.0im 1.0 + 0.0im], PhysicalOptics.var&quot;#conv#49&quot;{FFTW.rFFTWPlan{Float64,-1,false,2,UnitRange{Int64}},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.rFFTWPlan{Complex{Float64},1,false,2,UnitRange{Int64}},Float64}}(FFTW real-to-complex plan for 1×5 array of Float64
(rdft2-rank&gt;=2/1
  (rdft2-r2hc-rank0-x5)
  (dft-direct-5 &quot;n1fv_5_avx2_128&quot;)), 0.2 * FFTW complex-to-real plan for 1×5 array of Complex{Float64}
(rdft2-rank&gt;=2/1
  (rdft2-hc2r-rank0
    (rdft-rank0-iter-ci/1-x5))
  (dft-direct-5 &quot;n1bv_5_avx2_128&quot;))))

julia&gt; pconv(u, otf)
1×5 Array{Float64,2}:
 1.0  2.0  3.0  4.0  5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/convolutions.jl#L212-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.point_source_propagate-Tuple{Any, Any, Point}" href="#PhysicalOptics.point_source_propagate-Tuple{Any, Any, Point}"><code>PhysicalOptics.point_source_propagate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_source_propagate(L, size, point; λ=550e-9, n=1, dtype=ComplexF64)</code></pre><p>Propagate a point source in a field of width <code>L</code> with array size <code>size</code>  over a distance <code>z</code> in a medium with refractive index <code>n</code>. Point source is located at position <code>point(x, y, z)</code> and then propagated to  a location z=0. <code>z&lt;0</code> in <code>point</code> means forward propagation.</p><p>This is based on the analytical solution in real space and not on Fourier space propagation. The latter one suffers from artifacts while microscopic large <code>L</code>. This function should be always preferred for point sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.propagate!-Tuple{Any, Any, Any}" href="#PhysicalOptics.propagate!-Tuple{Any, Any, Any}"><code>PhysicalOptics.propagate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagate!(arr, L, z; kernel=rs_kernel, λ=550e-9, n=1)</code></pre><p>Propagate an electric field <code>arr</code> with a array size (in physical dimensions like meter etc) of <code>L</code> over the distance <code>z</code>. Per default <code>kernel=rs_kernel</code> (Rayleigh-Sommerfeld) is the propagation kernel.  <code>λ</code> is the wavelength and <code>n</code> the refractive index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.quadratic" href="#PhysicalOptics.quadratic"><code>PhysicalOptics.quadratic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadratic(arr, L, diameter, [, diameter=(0,0)])</code></pre><p>Apply a quadratic aperture of <code>diameter</code> to an  array which has a field width of <code>L</code>. The aperture is shifted by <code>Δx, Δy</code> with respect to the center</p><p>There is also an in-place version <code>quadratic!</code></p><pre><code class="language-julia-repl hljs">julia&gt; quadratic(ones((4, 4)), 10, 5)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0

julia&gt; quadratic(ones((5, 5)), 10, 5)
5×5 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0
 0.0  1.0  1.0  1.0  0.0
 0.0  1.0  1.0  1.0  0.0
 0.0  1.0  1.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0

julia&gt; quadratic(ones((5, 5)), 5, 2.5, (0.0, 1.25)) 
5×5 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0  1.0
 0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/apertures.jl#L90-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.rayleigh_criterion-Tuple{Any, Any}" href="#PhysicalOptics.rayleigh_criterion-Tuple{Any, Any}"><code>PhysicalOptics.rayleigh_criterion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rayleigh_criterion(focal_length, diameter; λ=500e-9)</code></pre><p>Calculates the resolution of a microscope according to Rayleigh. <code>focal_length</code> is the focal length of the lens. <code>λ</code> is the wavelength and <code>diameter</code> is the diameter of the aperture of the lens. See <a href="https://en.wikipedia.org/wiki/Angular_resolution#The_Rayleigh_criterion">Wikipedia</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rayleigh_criterion(100, 200)
3.05e-7

julia&gt; rayleigh_criterion(100, 200, λ=100e-9)
6.099999999999999e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/resolution_equations.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.rayleigh_criterion-Tuple{Any}" href="#PhysicalOptics.rayleigh_criterion-Tuple{Any}"><code>PhysicalOptics.rayleigh_criterion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rayleigh_criterion(NA; λ=500e-9)</code></pre><p>Calculates the resolution of a microscope according to Rayleigh. <code>λ</code> is the wavelength and <code>NA</code> the numerical aperture of the system. See <a href="https://en.wikipedia.org/wiki/Angular_resolution#The_Rayleigh_criterion">Wikipedia</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rayleigh_criterion(1.0)
3.05e-7

julia&gt; rayleigh_criterion(1.0, λ=100e-9)
6.099999999999999e-8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/resolution_equations.jl#L24-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.rr_old-Tuple{Any}" href="#PhysicalOptics.rr_old-Tuple{Any}"><code>PhysicalOptics.rr_old</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rr(s; L=nothing)</code></pre><p>Generate a array with values being the distance to the center pixel. <code>s</code> specifies the output size of the 2D array. <code>L</code> specifies the length. Can be a single number indicating the same length for both dimensions or a tuple specifying a length for each  dimension separately.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PhysicalOptics.rr((4,4))
4×4 Matrix{Float64}:
 2.82843  2.23607  2.0  2.23607
 2.23607  1.41421  1.0  1.41421
 2.0      1.0      0.0  1.0
 2.23607  1.41421  1.0  1.41421

julia&gt; PhysicalOptics.rr((4,4), L=1)
4×4 Matrix{Float64}:
 0.707107  0.559017  0.5   0.559017
 0.559017  0.353553  0.25  0.353553
 0.5       0.25      0.0   0.25
 0.559017  0.353553  0.25  0.353553

julia&gt; PhysicalOptics.rr((4,4), L=(5, 1))
4×4 Matrix{Float64}:
 2.54951  1.34629  0.5   1.34629
 2.51247  1.27475  0.25  1.27475
 2.5      1.25     0.0   1.25
 2.51247  1.27475  0.25  1.27475

julia&gt; PhysicalOptics.rr((5,5), L=(1, 1))
5×5 Matrix{Float64}:
 0.707107  0.559017  0.5   0.559017  0.707107
 0.559017  0.353553  0.25  0.353553  0.559017
 0.5       0.25      0.0   0.25      0.5
 0.559017  0.353553  0.25  0.353553  0.559017
 0.707107  0.559017  0.5   0.559017  0.707107</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/utils.jl#L254-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.rs_kernel" href="#PhysicalOptics.rs_kernel"><code>PhysicalOptics.rs_kernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rs_kernel(fx, fy, z, λ, n=1.0)</code></pre><p>Calculates the Rayleigh-Sommerfeld propagation kernel in Fourier space. <code>fx</code>, <code>f_y</code> are the spatial frequencies. <code>z</code> is the propagation distance. <code>λ</code> is the wavelength and <code>n</code> the refractive index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/propagations.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhysicalOptics.simple_psf-Tuple{Any, Any}" href="#PhysicalOptics.simple_psf-Tuple{Any, Any}"><code>PhysicalOptics.simple_psf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simple_psf(psf_size, radius; shift=false)</code></pre><p>Generation of an approximate 2D PSF. <code>psf_size</code> is the output size of the PSF. The PSF will be centered around the point [1, 1], <code>radius</code> indicates the pupil diameter in pixel from which the PSF is generated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; simple_psf([5, 5], 2)
5×5 Array{Float64,2}:
 0.36       0.104721    0.0152786    0.0152786    0.104721
 0.104721   0.0304627   0.00444444   0.00444444   0.0304627
 0.0152786  0.00444444  0.000648436  0.000648436  0.00444444
 0.0152786  0.00444444  0.000648436  0.000648436  0.00444444
 0.104721   0.0304627   0.00444444   0.00444444   0.0304627</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/PhysicalOptics.jl/blob/fecda8ef835d77517c39b600e522cfeaebb4a563/src/psf.jl#L19-L37">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Sunday 11 May 2025 01:35">Sunday 11 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
